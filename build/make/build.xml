<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
    Copyright 2005-2006 The Apache Software Foundation or its licensors, as applicable.
  
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
  
       http://www.apache.org/licenses/LICENSE-2.0
  
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<!--
Author:  Sergey V. Dmitriev
Version: $Revision: 1.16.2.20 $
-->

<!--
    Main targets:
        build (default) - builds all the components specified in
                          COMPONENTS property or all high level
                          components if COMPONENTS is not specified
        clean           - deletes everything generated by the build
                          previously
        update          - stores external resources locally
                          (must be executed before default the target)
        clean.update    - removes all the external resources which has
                          been stored locally before
        unit.test       - builds and runs unit tests for the
                          designated components
        smoke.test      - builds and runs smoke tests for the
                          designated components
        test            - builds and runs unit & smoke tests for the
                          designated components

    It is possible to specify the components to be built, via the
    COMPONENTS property.

    Usage example:
        (Windows)
        c:\harmony\vm> build.bat update
        c:\harmony\vm> build.bat -DCOMPONENTS="vm.interpeter vm.vmcore"

        (Linux)
        # ~/harmony/vm ./build.sh update
        # ~/harmony/vm ./build.sh -DCOMPONENTS="vm.interpeter vm.vmcore"

  -->

<project name="build" default="build">

    <target name="detect.os.arch.cxx.cfg">
        <property environment="env" />

        <!-- detecting current platform operation system -->
        <condition property="if.win" value="true">
            <contains string="${os.name}" substring="Windows" />
        </condition>
        <condition property="if.lnx" value="true">
            <not>
                <isset property="if.win" />
            </not>
        </condition>

        <!-- assigned only only under linux (see build.sh)-->
        <property name="machine.arch" value="${env.MACHINE_ARCH}" />

        <!-- detecting current platform arch -->
        <condition property="build.arch" value="ia32">
            <!-- os.arch: different values on Windows and Linux -->
            <or>
                <and>
                    <isset property="if.win" />
                    <equals arg1="${os.arch}" arg2="x86" />
                </and>
                <and>
                    <isset property="if.lnx" />
                    <equals arg1="${machine.arch}" arg2="i686" />
                </and>
            </or>
        </condition>

        <condition property="build.arch" value="ipf">
            <and>
                <isset property="if.lnx" />
                <equals arg1="${machine.arch}" arg2="ia64" />
            </and>
        </condition>

        <condition property="build.arch" value="em64t">
            <and>
                <isset property="if.lnx" />
                <equals arg1="${machine.arch}" arg2="x86_64" />
            </and>
        </condition>

        <condition property="properties.file" value="${env.properties.file}">
            <isset property="env.properties.file"/>
        </condition>
        <condition property="properties.file" value="win.properties">
            <isset property="if.win" />
        </condition>
        <property name="properties.file" value="lnx.properties" />
        <property name="resources.properties.file" value="${properties.file}" />
        <fail>
            <condition>
                <not>
                    <available file="${resources.properties.file}" />
                </not>
            </condition>Error:
*
* File ${resources.properties.file} not found.
*
        </fail>

        <loadproperties srcFile="${resources.properties.file}">
            <filterchain>
                <prefixlines prefix="env." />
                <tokenfilter>
                    <replaceregex pattern="\\" replace="/" flags="gi" />
                </tokenfilter>
            </filterchain>
        </loadproperties>

        <!-- build.cfg from command line -->
        <condition property="build.cfg" value="${BUILD_CFG}">
            <isset property="BUILD_CFG" />
        </condition>
        <condition property="build.cxx" value="${CXX}">
            <isset property="CXX" />
        </condition>
        <!-- build.cfg/cxx from environment or properties.file-->
        <property name="build.cfg" value="${env.BUILD_CFG}" />
        <property name="build.cxx" value="${env.CXX}" />

        <!-- build debug: true/false -->
        <condition property="build.is.debug" value="true">
            <equals arg1="${build.cfg}" arg2="debug" />
        </condition>
        <property name="build.is.debug" value="false" />
    </target>

    <!-- initialization target specific for linux -->
    <target name="init.lnx" if="if.lnx">
        <property name="build.os" value="Linux" />
        <property name="build.os.short" value="lnx" />
        <property name="build.executable.pattern" value="\1" />
        <property name="build.shared.pattern" value="lib\1.so lib\1.so.*" />
        <property name="build.static.pattern" value="lib\1.a" />
        <property name="build.jar.pattern" value="\1.jar" />
        <property name="build.other.pattern" value="\1" />
    </target>

    <!-- initialization target specific for windows -->
    <target name="init.win" if="if.win">
        <property name="build.os" value="Windows" />
        <property name="build.os.short" value="win" />
        <property name="build.executable.pattern" value="\1.exe \1.pdb" />
        <property name="build.shared.pattern" value="\1.dll \1.pdb" />
        <property name="build.static.pattern" value="\1.lib" />
        <property name="build.jar.pattern" value="\1.jar" />
        <property name="build.other.pattern" value="\1" />
    </target>

    <target name="set.externals" depends="set.semis.dirs">
        <loadproperties srcFile="${generated.properties.file}">
            <filterchain>
                <tokenfilter>
                    <replaceregex pattern="\\" replace="/" flags="gi" />
                </tokenfilter>
            </filterchain>
        </loadproperties>
    </target>

    <!-- plugin the ANTCONTRIB -->
    <target name="plugin.antcontrib" depends="set.externals">
        <!-- plug in the ANTCONTRIB -->
        <taskdef resource="net/sf/antcontrib/antlib.xml">
            <classpath>
                <pathelement location="tmp/ant-contrib.jar" />
            </classpath>
        </taskdef>
    </target>

    <target name="set.semis.dirs" depends="detect.os.arch.cxx.cfg,init.win,init.lnx">
        <property environment="env" />

        <!-- precopied folder location -->
        <property name="build.precopied.dir" location="../pre-copied" />

        <!-- semi-built component location -->
        <property name="build.semi.dir" location="../${build.os.short}_${build.arch}_${build.cxx}_${build.cfg}/semis" />
        <mkdir dir="${build.semi.dir}" />

        <property name="generated.properties.file" value="${build.semi.dir}/env.properties" />

        <!-- set Eclipse java compiler -->
        <property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter" />

        <!-- product binary deploy location -->
        <property name="build.deploy.dir" location="../${build.os.short}_${build.arch}_${build.cxx}_${build.cfg}/deploy/jre" />

        <!-- product doc deploy location -->
        <property name="build.deploy.doc.dir" location="../${build.os.short}_${build.arch}_${build.cxx}_${build.cfg}/docs" />
    </target>

    <target name="clean.update" depends="">
        <ant antfile="setup.xml" target="clean.update" inheritall="true" />
    </target>

    <target name="update" depends="detect.os.arch.cxx.cfg, set.semis.dirs">
        <ant antfile="setup.xml" target="update.external.resources" inheritall="true" />
    </target>

    <target name="plugin.cpptasks">
        <!-- plug in the CPPTASKS -->
        <taskdef resource="cpptasks.tasks">
            <classpath>
                <pathelement location="./tmp/cpptasks/patched.classes" />
                <pathelement location="./tmp/cpptasks/cpptasks.jar" />
            </classpath>
        </taskdef>
        <typedef resource="cpptasks.types">
            <classpath>
                <pathelement location="./tmp/cpptasks/patched.classes" />
                <pathelement location="./tmp/cpptasks/cpptasks.jar" />
            </classpath>
        </typedef>
    </target>


    <!-- initialization target: loading and setting build properties -->
    <target name="init" depends="detect.os.arch.cxx.cfg,
                                 init.lnx,
                                 init.win,
                                 set.semis.dirs,
                                 plugin.antcontrib,
                                 set.externals,
                                 plugin.cpptasks">
        <!-- load the product deploy info: components to copy to the place of deployment -->
        <xslt in="deploy.xml" out="${build.semi.dir}/deploy.xml" style="./selector.xsl">
            <param name="cfg" expression="${build.cfg}" />
            <param name="os" expression="${build.os.short}" />
            <param name="arch" expression="${build.arch}" />
            <param name="cxx" expression="${build.cxx}" />
        </xslt>

        <xmlproperty file="${build.semi.dir}/deploy.xml" keeproot="true" collapseAttributes="true" />

        <propertyselector property="build.deploy.all.components" delimiter=" " match="deploy\.(.+)\.(jar|shared|static|executable|other)" select="\1" distinct="true" override="true" />

        <!-- override COMPONENTS if not set -->
        <property name="COMPONENTS" value="deploy" />

        <if>
            <equals arg1="${COMPONENTS}" arg2="deploy" />
            <then>
                <property name="build.deploy.components" value="${build.deploy.all.components}" />
            </then>
            <else>
                <!-- Convert 'a b c' into 'a|b|c'.
                  -->
                <propertyregex property="build.deploy.components" input="${COMPONENTS}" regexp="\s+" replace="|" override="true" defaultValue="${COMPONENTS}" />

                <!-- Convert 'a.b.c' into 'a\.b\.c'.
                  -->
                <propertyregex property="build.deploy.components" input="${build.deploy.components}" regexp="\." replace="\\\\." override="true" global="true" defaultValue="${build.deploy.components}" />

                <!-- Select all properties like 'deploy.(a|b|c).XXX.(jar|...)'
                     and put them in one string separated with ' '.
                  -->
                <propertyselector property="build.deploy.components" delimiter=" " match="deploy\.((${build.deploy.components})(\.\w+)*)\.(jar|shared|static|executable|other)" select="\1" distinct="true" override="true" />
            </else>
        </if>

        <echo message="Configuration:" />
        <echo message="               os = ${build.os}" />
        <echo message="             arch = ${build.arch}" />
        <echo message="              cxx = ${build.cxx}" />
        <echo message="              cfg = ${build.cfg}" />
        <echo message="       components = ${COMPONENTS}" />
    </target>

    <target name="setup" depends="detect.os.arch.cxx.cfg, set.semis.dirs">
        <ant antfile="setup.xml" target="setup" inheritall="true" />
    </target>

    <!-- Main target for building components -->
    <target name="build" depends="setup, init, set.target.to.build, process.components, fill.up.deploy" />

    <target name="set.target.to.build">
        <property name="target" value="build" />
    </target>

    <!-- Main target for generating javadoc & deploying guildes -->
    <target name="doc" depends="init, set.target.to.doc, process.components, deploy.guides" />

    <target name="set.target.to.doc">
        <property name="target" value="doc" />
    </target>

    <!-- Deploys the guides -->
    <target name="deploy.guides">
        <mkdir dir="${build.deploy.doc.dir}/guides" />
        <copy todir="${build.deploy.doc.dir}/guides">
            <fileset dir="${build.VM.home}/doc">
                <include name="**/*" />
            </fileset>
        </copy>
    </target>

    <!-- Main target for tests run: call unit.test and smoke.test -->
    <target name="test" depends="setup, init, set.target.to.test">
        <condition property="component_to_test" value="vm">
            <equals arg1="${COMPONENTS}" arg2="deploy" />
            <!-- test means smoke test on vm -->
        </condition>
        <property name="component_to_test" value="${COMPONENTS}" />
        <subant buildpath="." antfile="build_component.xml" target="build" inheritall="true" failonerror="true">
            <property name="_component" value="${component_to_test}" />
            <property name="_target" value="${target}" />
        </subant>
    </target>

    <target name="set.target.to.test">
        <property name="target" value="test" />
    </target>

    <!-- Main target to run unit tests -->
    <target name="unit.test" depends="init, set.target.to.unit.test, process.components" />
    <target name="set.target.to.unit.test">
        <property name="target" value="unit.test" />
    </target>

    <!-- Main target to run smoke tests -->
    <target name="smoke.test" depends="init, set.target.to.smoke.test, process.components" />
    <target name="set.target.to.smoke.test">
        <property name="target" value="smoke.test" />
    </target>

    <!-- process (build/create javadoc/etc...) all the specified components -->
    <target name="process.components">
        <mkdir dir="${build.semi.dir}" />

        <for list="${COMPONENTS}" param="component" delimiter=" ">
            <sequential>
                <!-- call the component builder with parameters:
                        _component: component to process
                        _target:    action to perform with the
                                    component (build, doc, test)
                  -->
                <subant buildpath="." antfile="build_component.xml" target="build" inheritall="true" failonerror="true">
                    <property name="_component" value="@{component}" />
                    <property name="_target" value="${target}" />
                </subant>
            </sequential>
        </for>

        <for list="${build.deploy.components}" param="component" delimiter=" ">
            <sequential>
                <deploy-component component="@{component}" />
            </sequential>
        </for>
    </target>

    <!-- delete component binaries in semis and deploy -->
    <!-- do not touch pre-copied stuff (see clean.update target) -->
    <target name="clean" depends="detect.os.arch.cxx.cfg,
                                  init.lnx,
                                  init.win">
        <delete dir="../${build.os.short}_${build.arch}_${build.cxx}_${build.cfg}/harmony" failonerror="false" />
        <delete dir="../${build.os.short}_${build.arch}_${build.cxx}_${build.cfg}/deploy" failonerror="false" />
        <delete dir="../${build.os.short}_${build.arch}_${build.cxx}_${build.cfg}/semis" failonerror="false" />
    </target>

    <!-- put the rest of product (everything but components' output) to the deploy directory -->
    <target name="fill.up.deploy" depends="deploy.jni.n.jvmti.includes,
                                           deploy.readme,
                                           deploy.getting_started">
        <if>
            <and>
                <isset property="if.lnx" />
                <available type="dir" file="${build.deploy.dir}/bin" />
            </and>
            <then>
                <chmod perm="755">
                    <fileset dir="${build.deploy.dir}/bin">
                        <include name="ij" />
                        <include name="ij.sh" />
                        <include name="eclipse.sh" />
                        <include name="*.so" />
                        <include name="*.so.*" />
                    </fileset>
                </chmod>
            </then>
        </if>
    </target>

    <target name="deploy.jni.n.jvmti.includes">
        <copy todir="${build.deploy.dir}/include">
            <fileset dir="${build.VM.home}/include">
                <include name="jni_types.h" />
                <include name="jvmti_types.h" />
                <include name="jni.h" />
                <include name="jvmti.h" />
            </fileset>
        </copy>
    </target>

    <!-- create readme.txt in the deploy folder -->
    <target name="deploy.readme" depends="plugin.antcontrib, set.semis.dirs">
        <echo file="${build.deploy.dir}/readme.txt">

    Dynamic Runtime Layer (DRL)
    Binary Release for ${build.os}*/${build.arch}


This archive contains the Java* run-time environment.   


1. INSTALLATION INSTRUCTIONS
----------------------------

To install the product, extract this archive to a convenient location,
further referred to as &lt;EXTRACT_DIR&gt;.


2. ARCHIVE CONTENTS
-------------------

After extracting the archive, the following directories appear under
&lt;EXTRACT_DIR&gt;:

  bin         - Main DRL executable file and set of dynamic libraries
                needed for running
  doc         - Getting Started guide
  include     - Set of header files containing an external specification
  lib         - Compiled classes and other resources


3. SYSTEM REQUIREMENTS FOR RUNNING DRL
--------------------------------------

To use the DRL, install the product on a system with the ${build.arch} architecture and
the ${build.os}* operating system.

4. HOW TO RUN VM WITH DRL CLASS LIBRARIES
-----------------------------------------
</echo>

        <if>
            <isset property="if.win"/>
            <then>
<echo file="${build.deploy.dir}/readme.txt" append="true">
Use generic Java* conventions for launching ij.exe

    c:\drlvm&gt;cd bin
    c:\drlvm\bin&gt;ij -classpath . Hello
</echo>
            </then>
            <else>
	      <if>
		<equals arg1="${build.cxx}" arg2="icc"/>
		<then>
		<!-- ${CXX} == icc -->
<echo file="${build.deploy.dir}/readme.txt" append="true">
Use generic Java* conventions for launching ij

    $ cd bin
    $ LD_LIBRARY_PATH=${PWD}:&lt;Path to ICC libs&gt;:${LD_LIBRARY_PATH}; export LD_LIBRARY_PATH
    $ ./ij -classpath . Hello
</echo>
		</then>
		<else>
		<!-- ${CXX} != icc -->
<echo file="${build.deploy.dir}/readme.txt" append="true">
Use generic Java* conventions for launching ij

    $ cd bin
    $ LD_LIBRARY_PATH=${PWD}:${LD_LIBRARY_PATH}; export LD_LIBRARY_PATH
    $ ./ij -classpath . Hello
</echo>
		</else>
	      </if>
            </else>
        </if>

        <echo file="${build.deploy.dir}/readme.txt" append="true">


5. HOW TO SELECT THE EXECUTION MODE
-----------------------------------

By default, DRL runs with the just-in-time compiler enabled. 
To start DRL with the interpreter, supply the -Xint command-line option
right after the executable name.


6. DISCLAIMER AND LEGAL INFORMATION
------------------------------------

*) Other brands and names are the property of their respective owners.

This file was updated on March 14, 2006
</echo>
        <fixcrlf srcDir="${build.deploy.dir}" includes="readme.txt" />
    </target>


    <!-- Deploy the Getting Started document -->
    <target name="deploy.getting_started" depends="plugin.antcontrib, set.semis.dirs">
        <mkdir dir="${build.deploy.dir}/doc" />

        <copy todir="${build.deploy.dir}/doc">
            <fileset dir="${build.VM.home}/doc">
                <include name="images/**" />
                <include name="drl.css" />
                <include name="GettingStarted.htm" />
            </fileset>
        </copy>

        <fixcrlf srcDir="${build.deploy.dir}/doc" includes="*.htm *.css" />
    </target>


    <!--
        Handles the component output (like: built component, create javadoc, build & run tests).
        @param component: component name, like "vm.vmcore"
      -->
    <macrodef name="deploy-component">
        <attribute name="component" />
        <sequential>
            <!-- convert 'extra.zlib' to 'extra/zlib' -->
            <propertyregex property="component.as.path" input="@{component}" regexp="\." replace="/" global="true" defaultValue="@{component}" override="true" />

            <for list="jar,executable,shared,static,other" param="deploy.property.tail" delimiter=",">
                <sequential>
                    <if>
                        <isset property="deploy.@{component}.@{deploy.property.tail}" />
                        <then>
                            <!-- 'lib:luni': select 'lib' from it -->
                            <propertyregex property="component.deploy.filedir" input="${deploy.@{component}.@{deploy.property.tail}}" regexp="(.+):.+" select="\1" defaultValue="${deploy.@{component}.@{deploy.property.tail}}" override="true" />

                            <!-- 'lib:luni': select 'luni' from it -->
                            <propertyregex property="component.deploy.filenames" input="${deploy.@{component}.@{deploy.property.tail}}" regexp=".+:(.+)" select="\1" defaultValue="${deploy.@{component}.@{deploy.property.tail}}" override="true" />

                            <!-- filenames: 'luni,luni2' -->
                            <!-- pattern:   'lib\1.so,lib\1.so.34' -->
                            <!-- output:    'libluni.so,libluni.so.34,libluni2.so,libluni.so.34' -->
                            <!-- note the last comma in input and output -->
                            <propertyregex property="component.deploy.filenames" input="${component.deploy.filenames}," regexp="(.+),\s*" replace="${build.@{deploy.property.tail}.pattern}," global="true" defaultValue="${component.deploy.filenames}" override="true" />

                            <mkdir dir="${build.deploy.dir}/${component.deploy.filedir}" />
                            <switch value="@{deploy.property.tail}">
                                <case value="jar">
                                    <copy todir="${build.deploy.dir}/${component.deploy.filedir}" verbose="true">
                                        <fileset dir="${build.semi.dir}/${component.as.path}/_jar" includes="${component.deploy.filenames}" />
                                    </copy>
                                </case>
                                <case value="other">
                                    <copy todir="${build.deploy.dir}/${component.deploy.filedir}" verbose="true">
                                        <fileset dir="${build.semi.dir}/${component.as.path}/_other" includes="${component.deploy.filenames}" />
                                    </copy>
                                </case>
                                <default>
                                    <copy todir="${build.deploy.dir}/${component.deploy.filedir}" verbose="true">
                                        <fileset dir="${build.semi.dir}/${component.as.path}/_bin" includes="${component.deploy.filenames}" />
                                    </copy>
                                </default>
                            </switch>
                        </then>
                    </if>
                </sequential>
            </for>
        </sequential>
    </macrodef>
</project>
